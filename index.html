<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dream Archive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Gallery View Component
        function GalleryView() {
            const [entries, setEntries] = useState([]);
            const [loading, setLoading] = useState(true);
            const [selectedEntry, setSelectedEntry] = useState(null);
            const [filterKeyword, setFilterKeyword] = useState('');
            const [searchText, setSearchText] = useState('');
            const [error, setError] = useState(null);

            useEffect(() => {
                loadEntries();
            }, []);

            const loadEntries = async () => {
                setLoading(true);
                setError(null);
        
                try {
                    const indexResponse = await fetch('./index.json');
                    if (!indexResponse.ok) {
                        throw new Error('Could not load index.json');
                    }
          
                    const indexData = await indexResponse.json();
                    const entryIds = indexData.entries || [];

                    const loadedEntries = [];
                    for (const id of entryIds) {
                        try {
                            const entryResponse = await fetch(`./entries/${id}.json`);
                            if (entryResponse.ok) {
                                const entryData = await entryResponse.json();
                                loadedEntries.push(entryData);
                            } else {
                                console.warn(`Could not load entry: ${id}`);
                            }
                        } catch (err) {
                            console.warn(`Error loading entry ${id}:`, err);
                        }
                    }

                    loadedEntries.sort((a, b) => new Date(b.date) - new Date(a.date));
                    setEntries(loadedEntries);
                } catch (err) {
                    console.error('Error loading entries:', err);
                    setError(err.message);
                } finally {
                    setLoading(false);
                }
            };

            const formatDate = (dateString) => {
                const date = new Date(dateString + 'T00:00:00');
                return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
            };

            const filterEntries = () => {
                let filtered = entries;

                if (filterKeyword) {
                    filtered = filtered.filter(entry => 
                        entry.keywords && entry.keywords.some(k => 
                            k.toLowerCase() === filterKeyword.toLowerCase()
                        )
                    );
                }

                if (searchText) {
                    const searchLower = searchText.toLowerCase();
                    filtered = filtered.filter(entry => {
                        const summaryMatch = entry.summary && entry.summary.toLowerCase().includes(searchLower);
                        const sceneMatch = entry.scenes && entry.scenes.some(scene => 
                            scene.text.toLowerCase().includes(searchLower)
                        );
                        return summaryMatch || sceneMatch;
                    });
                }

                return filtered;
            };

            const clearFilters = () => {
                setFilterKeyword('');
                setSearchText('');
            };

            const handleKeywordClick = (keyword) => {
                setFilterKeyword(keyword);
            };

            const openDetail = (entry) => {
                setSelectedEntry(entry);
            };

            const closeDetail = () => {
                setSelectedEntry(null);
            };

            const filteredEntries = filterEntries();

            if (loading) {
                return (
                    <div className="max-w-7xl mx-auto p-6">
                        <div className="text-center py-12">
                            <div className="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
                            <p className="mt-4 text-gray-600">Loading dreams...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="max-w-7xl mx-auto p-6">
                        <div className="bg-red-50 border border-red-200 rounded p-6 text-center">
                            <p className="text-red-700">Error loading dream archive: {error}</p>
                            <button 
                                onClick={loadEntries}
                                className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
                            >
                                Retry
                            </button>
                        </div>
                    </div>
                );
            }

            if (entries.length === 0) {
                return (
                    <div className="max-w-7xl mx-auto p-6">
                        <div className="text-center py-12">
                            <p className="text-xl text-gray-600">No dreams archived yet. Add your first dream!</p>
                        </div>
                    </div>
                );
            }

            if (selectedEntry) {
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 overflow-y-auto">
                        <div className="min-h-screen px-4 py-8">
                            <div className="max-w-4xl mx-auto bg-white rounded-lg shadow-xl">
                                <div className="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between rounded-t-lg">
                                    <h2 className="text-2xl font-bold text-gray-800">
                                        {formatDate(selectedEntry.date)}
                                    </h2>
                                    <button
                                        onClick={closeDetail}
                                        className="text-gray-500 hover:text-gray-700 text-2xl font-bold"
                                    >
                                        ×
                                    </button>
                                </div>

                                <div className="p-6">
                                    {selectedEntry.keywords && selectedEntry.keywords.length > 0 && (
                                        <div className="mb-6 flex flex-wrap gap-2">
                                            {selectedEntry.keywords.map((keyword, i) => (
                                                <span
                                                    key={i}
                                                    className="px-3 py-1 bg-blue-100 text-blue-700 text-sm rounded-full"
                                                >
                                                    {keyword}
                                                </span>
                                            ))}
                                        </div>
                                    )}

                                    {selectedEntry.summary && (
                                        <div className="mb-8">
                                            <h3 className="text-lg font-semibold text-gray-700 mb-2">Summary</h3>
                                            <p className="text-gray-600 leading-relaxed">{selectedEntry.summary}</p>
                                        </div>
                                    )}

                                    <div className="space-y-8">
                                        <h3 className="text-lg font-semibold text-gray-700">Scenes</h3>
                                        {selectedEntry.scenes && selectedEntry.scenes.map((scene, i) => (
                                            <div key={i} className="space-y-3">
                                                <img
                                                    src={`./${scene.image}`}
                                                    alt={`Scene ${i + 1}`}
                                                    className="w-full rounded-lg shadow-md"
                                                    onError={(e) => {
                                                        e.target.style.display = 'none';
                                                        console.error(`Failed to load image: ${scene.image}`);
                                                    }}
                                                />
                                                <p className="text-gray-700 leading-relaxed">{scene.text}</p>
                                            </div>
                                        ))}
                                    </div>

                                    {selectedEntry.fragments && selectedEntry.fragments.length > 0 && (
                                        <div className="mt-8 pt-8 border-t border-gray-200">
                                            <h3 className="text-lg font-semibold text-gray-700 mb-3">Fragments</h3>
                                            <ul className="space-y-2">
                                                {selectedEntry.fragments.map((fragment, i) => (
                                                    <li key={i} className="text-gray-600 italic">• {fragment}</li>
                                                ))}
                                            </ul>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="max-w-7xl mx-auto p-6">
                    <div className="mb-6 space-y-4">
                        <div className="flex gap-4 flex-wrap">
                            <input
                                type="text"
                                placeholder="Search dreams..."
                                value={searchText}
                                onChange={(e) => setSearchText(e.target.value)}
                                className="flex-1 min-w-64 px-4 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                            {(filterKeyword || searchText) && (
                                <button
                                    onClick={clearFilters}
                                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                                >
                                    Clear Filters
                                </button>
                            )}
                        </div>

                        {filterKeyword && (
                            <div className="flex items-center gap-2">
                                <span className="text-sm text-gray-600">Filtering by:</span>
                                <span className="px-3 py-1 bg-blue-100 text-blue-700 text-sm rounded-full">
                                    {filterKeyword}
                                </span>
                            </div>
                        )}

                        <p className="text-sm text-gray-600">
                            Showing {filteredEntries.length} of {entries.length} dreams
                        </p>
                    </div>

                    {filteredEntries.length === 0 ? (
                        <div className="text-center py-12">
                            <p className="text-xl text-gray-600">No dreams match your filters.</p>
                            <button
                                onClick={clearFilters}
                                className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                            >
                                Clear Filters
                            </button>
                        </div>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {filteredEntries.map((entry, index) => (
                                <div
                                    key={index}
                                    onClick={() => openDetail(entry)}
                                    className="bg-white border border-gray-200 rounded-lg overflow-hidden shadow hover:shadow-lg transition-shadow cursor-pointer"
                                >
                                    {entry.scenes && entry.scenes.length > 0 && entry.scenes[0].image && (
                                        <div className="aspect-video bg-gray-100">
                                            <img
                                                src={`./${entry.scenes[0].image}`}
                                                alt="Dream thumbnail"
                                                className="w-full h-full object-cover"
                                                onError={(e) => {
                                                    e.target.style.display = 'none';
                                                }}
                                            />
                                        </div>
                                    )}
                  
                                    <div className="p-4">
                                        <h3 className="font-semibold text-gray-800 mb-2">
                                            {formatDate(entry.date)}
                                        </h3>
                    
                                        {entry.keywords && entry.keywords.length > 0 && (
                                            <div className="flex flex-wrap gap-2 mb-2">
                                                {entry.keywords.slice(0, 3).map((keyword, i) => (
                                                    <span
                                                        key={i}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            handleKeywordClick(keyword);
                                                        }}
                                                        className="px-2 py-1 bg-blue-50 text-blue-600 text-xs rounded-full hover:bg-blue-100 cursor-pointer"
                                                    >
                                                        {keyword}
                                                </span>
                                                ))}
                                            </div>
                                        )}
                    
                                        {entry.summary && (
                                            <p className="text-sm text-gray-600 line-clamp-2">
                                                {entry.summary}
                                            </p>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        // Add Entry Form Component
        function AddEntryForm() {
                const [date, setDate] = useState(new Date().toISOString().split('T')[0]);
                const [originalTranscription, setOriginalTranscription] = useState('');
                const [summary, setSummary] = useState('');
                const [keywords, setKeywords] = useState('');
                const [scenes, setScenes] = useState([{ text: '', image: null, imagePreview: null }]);
                const [fragments, setFragments] = useState('');
                const [errors, setErrors] = useState([]);
                const [successMessage, setSuccessMessage] = useState('');
                const fileInputRefs = useRef([]);
                const [jsonText, setJsonText] = useState('');
                const [isParsed, setIsParsed] = useState(false);

                const SAMPLE_JSON = `{
  "date": "2026-01-16",
  "originalTranscription": "I was walking through a huge unfinished building that felt like a mix between a university, an airport, and an office tower. Some hallways were pristine and modern, others were crumbling or blocked off. I kept carrying different bags with me, but every time I set one down to pick up another, I felt anxious that I was abandoning something important. At one point I found a control room filled with glowing screens showing projects, timelines, and symbols I recognized but couldn't fully read. A voice told me I had plenty of time, but the building lights kept dimming. I tried to find an exit, but each door led me deeper inside instead of outside.",
  "summary": "A restless dream about unfinished structures, competing responsibilities, and the pressure to integrate many paths into a coherent whole. The emotional arc moves from curiosity and competence into quiet urgency, with a lingering tension between having time and fearing loss.",
  "keywords": [
    "unfinished building",
    "corridors",
    "responsibility",
    "time",
    "choice",
    "abandonment",
    "control room",
    "integration"
  ],
  "scenes": [
    "I was inside a massive building with endless corridors. Some areas looked like a modern research lab, others like an old crumbling university wing. I knew all of it belonged to me, but none of it felt complete.",
    "I carried multiple bags, each one heavy in a different way. Whenever I set one down to pick up another, I felt a sharp anxiety that I was leaving something essential behind.",
    "I entered a control room filled with glowing screens showing symbols, charts, and timelines that felt deeply familiar. I couldn't quite read them, but I knew they represented long-term plans and identities.",
    "A calm voice told me there was no rush and that I had time. At the same moment, the lights in the building began to dim, and I felt a quiet urgency to move.",
    "I searched for an exit, but every door I opened led to another interior hallway. The building folded inward, and I realized I was still inside myself."
  ],
  "fragments": [
    "A staircase that spiraled both up and down at the same time",
    "A badge around my neck with no name printed on it",
    "A sense that someone was waiting for me outside the building",
    "The hum of electricity even in empty rooms"
  ]
}`;

                const parseJson = () => {
                        setErrors([]);
                        try {
                                const parsed = JSON.parse(jsonText);
                
                                if (parsed.date) setDate(parsed.date);
                                setOriginalTranscription(parsed.originalTranscription || '');
                                setSummary(parsed.summary || '');
                
                                if (Array.isArray(parsed.keywords)) {
                                        setKeywords(parsed.keywords.join(', '));
                                } else if (typeof parsed.keywords === 'string') {
                                        setKeywords(parsed.keywords);
                                }
                
                                if (parsed.scenes && Array.isArray(parsed.scenes)) {
                                        const newScenes = parsed.scenes.map(scene => ({
                                                text: typeof scene === 'string' ? scene : (scene.text || ''),
                                                image: null,
                                                imagePreview: null
                                        }));
                                        setScenes(newScenes);
                                }
                
                                if (parsed.fragments && Array.isArray(parsed.fragments)) {
                                        setFragments(parsed.fragments.join('\n'));
                                }
                
                                setIsParsed(true);
                        } catch (error) {
                                setErrors([`Failed to parse JSON: ${error.message}`]);
                        }
                };

                const handleImageUpload = (index, e) => {
                        const file = e.target.files[0];
                        if (file) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                        const newScenes = [...scenes];
                                        newScenes[index].image = file;
                                        newScenes[index].imagePreview = event.target.result;
                                        setScenes(newScenes);
                                };
                                reader.readAsDataURL(file);
                        }
                };

                const validateForm = () => {
                        const newErrors = [];
                        if (!date) newErrors.push('Date is required');

                        let hasValidScene = false;
                        scenes.forEach((scene, index) => {
                                if (scene.text) {
                                        hasValidScene = true;
                                } else if (scene.image) {
                                        newErrors.push(`Scene ${index + 1}: Text is required for all scenes`);
                                }
                        });

                        if (!hasValidScene) {
                                newErrors.push('At least one scene must have text');
                        }

                        setErrors(newErrors);
                        return newErrors.length === 0;
                };

                const generateFiles = async () => {
                        setErrors([]);
                        setSuccessMessage('');

                        if (!validateForm()) return;

                        try {
                                const JSZip = window.JSZip;
                                const zip = new JSZip();

                                const keywordsArray = keywords.split(',').map(k => k.trim()).filter(k => k.length > 0);
                                const fragmentsArray = fragments.split('\n').map(f => f.trim()).filter(f => f.length > 0);
                                const validScenes = scenes.filter(scene => scene.text);

                                const jsonData = {
                                        date: date,
                                        originalTranscription: originalTranscription,
                                        summary: summary,
                                        keywords: keywordsArray,
                                        scenes: validScenes.map((scene, index) => {
                                                const sceneData = { text: scene.text };
                                                if (scene.image) {
                                                        const extension = scene.image.name.split('.').pop();
                                                        const sceneNumber = String(index + 1).padStart(2, '0');
                                                        sceneData.image = `images/${date}-${sceneNumber}.${extension}`;
                                                }
                                                return sceneData;
                                        }),
                                        fragments: fragmentsArray
                                };

                                zip.file(`entries/${date}.json`, JSON.stringify(jsonData, null, 2));

                                // Only process scenes that have images
                                for (let i = 0; i < validScenes.length; i++) {
                                        const scene = validScenes[i];
                                        if (scene.image) {
                                                const extension = scene.image.name.split('.').pop();
                                                const sceneNumber = String(i + 1).padStart(2, '0');
                                                const fileName = `images/${date}-${sceneNumber}.${extension}`;

                                                const imageData = await new Promise((resolve, reject) => {
                                                        const reader = new FileReader();
                                                        reader.onload = (e) => resolve(e.target.result);
                                                        reader.onerror = reject;
                                                        reader.readAsArrayBuffer(scene.image);
                                                });

                                                zip.file(fileName, imageData);
                                        }
                                }

                                const content = await zip.generateAsync({ type: 'blob' });
                                window.saveAs(content, `dream-${date}.zip`);

                                setSuccessMessage(`Add this to index.json at the top of the "entries" array:\n"${date}",`);

                                setTimeout(() => clearForm(), 5000);

                        } catch (error) {
                                setErrors([`Error generating files: ${error.message}`]);
                        }
                };

                const clearForm = () => {
                        setDate(new Date().toISOString().split('T')[0]);
                        setOriginalTranscription('');
                        setSummary('');
                        setKeywords('');
                        setScenes([{ text: '', image: null, imagePreview: null }]);
                        setFragments('');
                        setErrors([]);
                        setSuccessMessage('');
                        fileInputRefs.current = [];
                        setJsonText('');
                        setIsParsed(false);
                };

                const loadSampleJson = () => {
                        setJsonText(SAMPLE_JSON);
                };

                return (
                        <div className="max-w-4xl mx-auto p-6">
                                {errors.length > 0 && (
                                        <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded">
                                                {errors.map((error, index) => (
                                                        <p key={index} className="text-sm text-red-700">{error}</p>
                                                ))}
                                        </div>
                                )}

                                {successMessage && (
                                        <div className="mb-4 p-4 bg-green-50 border border-green-200 rounded">
                                                <p className="text-sm text-green-700 font-semibold">Success! Files generated.</p>
                                                <p className="text-sm text-green-700 mt-2 whitespace-pre-wrap font-mono">{successMessage}</p>
                                        </div>
                                )}

                                <div className="space-y-6">
                                        {!isParsed ? (
                                                <div className="space-y-4">
                                                        <div className="p-4 bg-purple-50 border border-purple-200 rounded">
                                                                <div className="flex items-center justify-between mb-3">
                                                                        <h3 className="font-semibold text-purple-900">Dream Structuring Prompt Template</h3>
                                                                        <button
                                                                                onClick={() => navigator.clipboard.writeText(`I just had a dream. Here's my raw voice dump:

[PASTE YOUR TRANSCRIPTION HERE]

---

Please organize this dream into JSON format for the Dream Archive webapp. **Important**: Preserve the dream's natural logic—don't rationalize impossible elements, sudden transitions, or identity shifts. Dreams don't follow waking logic, and that's what makes them worth preserving.

**Output valid JSON with this exact structure:**

{
  "originalTranscription": "The original raw dream transcription text",
  "summary": "2-3 sentences capturing the emotional arc and main experience of the dream. Focus on the feeling and atmosphere, not literal events.",
  "keywords": ["keyword1", "keyword2", "keyword3", "etc"],
  "scenes": [
    "Scene 1: A specific location or situation with 2-3 sentences describing what happened. Preserve 'suddenly I was...' transitions, identity fluidity, and spatial contradictions.",
    "Scene 2: Another scene description...",
    "Scene 3+: Continue for 3-7 key moments"
  ],
  "fragments": ["disconnected flash or detail 1", "detail 2", "etc"]
}

**Requirements:**
- scenes: Array of strings, each describing a distinct scene (3-7 scenes)
- keywords: Array of 5-8 single-word or short-phrase tags (symbols, emotions, settings, characters)
- fragments: Array of disconnected details that don't fit in scenes (use empty array [] if none)
- summary: 2-3 sentences on emotional arc and atmosphere
- originalTranscription: The raw dream text you were given

**Example JSON:**
{
  "originalTranscription": "I was in my childhood kitchen but the walls were breathing. Water was rising from the floor tiles...",
  "summary": "A dream about returning to a familiar space that has become alien and unstable. The emotional core was a mix of nostalgia and dislocation, with a thread of loss running through the changing identities and disappearing spaces.",
  "keywords": ["water", "childhood home", "father", "transformation", "loss", "ocean", "disorientation", "identity"],
  "scenes": [
    "I was in my childhood kitchen, but the walls were breathing. Water was rising from the floor tiles, pooling around my ankles. Everything felt both familiar and completely wrong.",
    "My father appeared in the doorway, but he was the age I am now. He didn't recognize me. He asked if I'd seen his daughter.",
    "Suddenly I was outside. The house had become an island in the middle of an endless ocean. The sky was the wrong color—a deep purple I've never seen in waking life."
  ],
  "fragments": ["There was a red door that shouldn't have existed", "My dog was there for a moment, then wasn't", "Someone was calling my name but I couldn't tell from where", "The water tasted like salt even though it was coming from the floor"]
}

---

## Example Output Format

### Scene Breakdown
1. I was in my childhood kitchen, but the walls were breathing. Water was rising from the floor tiles, pooling around my ankles. Everything felt both familiar and completely wrong.

2. My father appeared in the doorway, but he was the age I am now. He didn't recognize me. He asked if I'd seen his daughter.

3. Suddenly I was outside. The house had become an island in the middle of an endless ocean. The sky was the wrong color—a deep purple I've never seen in waking life.

### Core Summary
A dream about returning to a familiar space that has become alien and unstable. The emotional core was a mix of nostalgia and dislocation, with a thread of loss running through the changing identities and disappearing spaces.

### Visual Moments
Scene 1: Childhood kitchen flooding with dark water, walls subtly distorting, warm dim light through windows, atmosphere of creeping wrongness

Scene 2: Middle-aged man in doorway backlit by strange light, expression of confusion and searching, dreamlike soft focus

Scene 3: Small house on tiny island surrounded by vast purple-sky ocean, impossible perspective, sense of isolation and awe

### Keywords
water, childhood home, father, transformation, loss, ocean, disorientation, identity

### Fragments
- There was a red door that shouldn't have existed
- My dog was there for a moment, then wasn't
- Someone was calling my name but I couldn't tell from where
- The water tasted like salt even though it was coming from the floor

---

## After ChatGPT Responds

Copy each section into the corresponding field in the Add Entry form:
- Scene text → Scene fields (create one scene per numbered item)
- Summary → Summary field
- Keywords → Keywords field
- Visual Moments → Use these to generate images in Sora/Gemini
- Fragments → Fragments field

Generate images for 3-5 of the Visual Moments, then upload to corresponding scenes in the form.`)}
                                                                                className="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700"
                                                                        >
                                                                                Copy Template
                                                                        </button>
                                                                </div>
                                                                <div className="text-sm text-purple-800 bg-white p-3 rounded border font-mono whitespace-pre-wrap max-h-60 overflow-y-auto">
{`I just had a dream. Here's my raw voice dump:

[PASTE YOUR TRANSCRIPTION HERE]

---

Please organize this dream into JSON format for the Dream Archive webapp. **Important**: Preserve the dream's natural logic—don't rationalize impossible elements, sudden transitions, or identity shifts. Dreams don't follow waking logic, and that's what makes them worth preserving.

**Output valid JSON with this exact structure:**

{
  "originalTranscription": "The original raw dream transcription text",
  "summary": "2-3 sentences capturing the emotional arc and main experience of the dream. Focus on the feeling and atmosphere, not literal events.",
  "keywords": ["keyword1", "keyword2", "keyword3", "etc"],
  "scenes": [
    "Scene 1: A specific location or situation with 2-3 sentences describing what happened. Preserve 'suddenly I was...' transitions, identity fluidity, and spatial contradictions.",
    "Scene 2: Another scene description...",
    "Scene 3+: Continue for 3-7 key moments"
  ],
  "fragments": ["disconnected flash or detail 1", "detail 2", "etc"]
}

**Requirements:**
- scenes: Array of strings, each describing a distinct scene (3-7 scenes)
- keywords: Array of 5-8 single-word or short-phrase tags (symbols, emotions, settings, characters)
- fragments: Array of disconnected details that don't fit in scenes (use empty array [] if none)
- summary: 2-3 sentences on emotional arc and atmosphere
- originalTranscription: The raw dream text you were given`}
                                                                </div>
                                                                <p className="text-xs text-purple-700 mt-2">
                                                                        Copy this template and paste it into ChatGPT along with your dream transcription. ChatGPT will organize it into JSON that you can paste directly below.
                                                                </p>
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                                                        Paste Dream JSON from ChatGPT
                                                                </label>
                                                                <textarea
                                                                        value={jsonText}
                                                                        onChange={(e) => setJsonText(e.target.value)}
                                                                        rows={12}
                                                                        placeholder="Paste your dream JSON here..."
                                                                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"
                                                                />
                                                        </div>
                            
                                                        <div className="flex gap-3">
                                                                <button
                                                                        onClick={parseJson}
                                                                        className="px-6 py-3 bg-blue-600 text-white font-medium rounded hover:bg-blue-700"
                                                                >
                                                                        Parse Dream
                                                                </button>
                                                                <button
                                                                        onClick={loadSampleJson}
                                                                        className="px-6 py-3 bg-indigo-600 text-white font-medium rounded hover:bg-indigo-700"
                                                                >
                                                                        Load Mock Dream
                                                                </button>
                                                                <button
                                                                        onClick={() => setJsonText('')}
                                                                        className="px-6 py-3 bg-gray-200 text-gray-700 font-medium rounded hover:bg-gray-300"
                                                                >
                                                                        Clear
                                                                </button>
                                                        </div>

                                                        <div className="p-4 bg-blue-50 border border-blue-200 rounded">
                                                                <h3 className="font-semibold text-blue-900 mb-2">Expected JSON Format:</h3>
                                                                <pre className="text-xs text-blue-800 font-mono overflow-x-auto">{SAMPLE_JSON}</pre>
                                                        </div>
                                                </div>
                                        ) : (
                                                <>
                                                        <div className="p-4 bg-green-50 border border-green-200 rounded">
                                                                <p className="text-sm text-green-700">✓ Dream parsed successfully! Fields are now read-only. Upload images for each scene below.</p>
                                                                <button
                                                                        onClick={() => {
                                                                                setIsParsed(false);
                                                                                setJsonText('');
                                                                        }}
                                                                        className="mt-2 text-sm text-green-700 underline hover:text-green-800"
                                                                >
                                                                        Start over with new JSON
                                                                </button>
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-2">Date *</label>
                                                                <input
                                                                        type="date"
                                                                        value={date}
                                                                        className="w-full px-3 py-2 border border-gray-300 rounded bg-gray-100"
                                                                        readOnly
                                                                        disabled
                                                                />
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-2">Original Transcription</label>
                                                                <textarea
                                                                        value={originalTranscription}
                                                                        rows={8}
                                                                        className="w-full px-3 py-2 border border-gray-300 rounded bg-gray-100"
                                                                        readOnly
                                                                        disabled
                                                                />
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-2">Summary</label>
                                                                <textarea
                                                                        value={summary}
                                                                        rows={3}
                                                                        className="w-full px-3 py-2 border border-gray-300 rounded bg-gray-100"
                                                                        readOnly
                                                                        disabled
                                                                />
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-2">Keywords</label>
                                                                <input
                                                                        type="text"
                                                                        value={keywords}
                                                                        className="w-full px-3 py-2 border border-gray-300 rounded bg-gray-100"
                                                                        readOnly
                                                                        disabled
                                                                />
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-4">
                                                                        Scenes * - Upload images for each scene
                                                                </label>

                                                                {scenes.map((scene, index) => (
                                                                        <div key={index} className="mb-6 p-4 border border-gray-200 rounded bg-white">
                                                                                <h3 className="text-sm font-medium text-gray-700 mb-3">Scene {index + 1}</h3>

                                                                                <div className="mb-3 p-3 bg-gray-50 rounded">
                                                                                        <p className="text-sm text-gray-700">{scene.text}</p>
                                                                                </div>

                                                                                <div>
                                                                                        <input
                                                                                                type="file"
                                                                                                accept="image/*"
                                                                                                onChange={(e) => handleImageUpload(index, e)}
                                                                                                ref={(el) => (fileInputRefs.current[index] = el)}
                                                                                                className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                                                                        />
                                                                                        {scene.imagePreview && (
                                                                                                <img
                                                                                                        src={scene.imagePreview}
                                                                                                        alt={`Scene ${index + 1} preview`}
                                                                                                        className="mt-3 max-w-xs rounded border border-gray-300"
                                                                                                />
                                                                                        )}
                                                                                </div>
                                                                        </div>
                                                                ))}
                                                        </div>

                                                        <div>
                                                                <label className="block text-sm font-medium text-gray-700 mb-2">Fragments (optional)</label>
                                                                <textarea
                                                                        value={fragments}
                                                                        rows={4}
                                                                        className="w-full px-3 py-2 border border-gray-300 rounded bg-gray-100"
                                                                        readOnly
                                                                        disabled
                                                                />
                                                        </div>

                                                        <div className="flex gap-4">
                                                                <button
                                                                        onClick={generateFiles}
                                                                        className="px-6 py-3 bg-green-600 text-white font-medium rounded hover:bg-green-700"
                                                                >
                                                                        Generate Entry Files
                                                                </button>
                                                                <button
                                                                        onClick={clearForm}
                                                                        className="px-6 py-3 bg-gray-200 text-gray-700 font-medium rounded hover:bg-gray-300"
                                                                >
                                                                        Clear Form
                                                                </button>
                                                        </div>
                                                </>
                                        )}
                                </div>
                        </div>
                );
        }

        // Main App Component
        function App() {
            const [currentView, setCurrentView] = useState('gallery');

            return (
                <div className="min-h-screen bg-gray-50">
                    <header className="bg-white shadow-sm border-b border-gray-200">
                        <div className="max-w-7xl mx-auto px-6 py-4">
                            <div className="flex items-center justify-between">
                                <h1 className="text-2xl font-bold text-gray-900">Dream Archive</h1>
                                <nav className="flex gap-2">
                                    <button
                                        onClick={() => setCurrentView('gallery')}
                                        className={`px-4 py-2 rounded font-medium transition-colors ${
                                            currentView === 'gallery'
                                                ? 'bg-blue-600 text-white'
                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                        }`}
                                    >
                                        Gallery
                                    </button>
                                    <button
                                        onClick={() => setCurrentView('add')}
                                        className={`px-4 py-2 rounded font-medium transition-colors ${
                                            currentView === 'add'
                                                ? 'bg-blue-600 text-white'
                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                        }`}
                                    >
                                        Add Entry
                                    </button>
                                </nav>
                            </div>
                        </div>
                    </header>

                    <main className="py-6">
                        {currentView === 'gallery' ? <GalleryView /> : <AddEntryForm />}
                    </main>
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>